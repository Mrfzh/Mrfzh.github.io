<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">










  <meta name="google-site-verification" content="X7_M3eeaLhvcnX4TXnFCfa8gF_OXS5CEpA0zKHEBuLY">















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/F-32x21.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/F-16x16.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.0',
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="简介 volatile的本义是易变的、不稳定的。volatile关键字修饰的变量随时可能被其他线程修改。当volatile变量的值被修改时，主存中值的更新会使缓存中的值失效（非volatile变量不具备这样的特性，非volatile变量的值会被缓存，线程A更新了该值，但线程B读到的值可能并不是最新的值，而是缓存的值），所以被volatile修饰的变量能够保证每个线程能够获取该变量的最新值。">
<meta name="keywords" content="并发,线程">
<meta property="og:type" content="article">
<meta property="og:title" content="volatile关键字详解">
<meta property="og:url" content="https://mrfzh.github.io/2019/05/08/volatile关键字详解/index.html">
<meta property="og:site_name" content="FengZH的博客">
<meta property="og:description" content="简介 volatile的本义是易变的、不稳定的。volatile关键字修饰的变量随时可能被其他线程修改。当volatile变量的值被修改时，主存中值的更新会使缓存中的值失效（非volatile变量不具备这样的特性，非volatile变量的值会被缓存，线程A更新了该值，但线程B读到的值可能并不是最新的值，而是缓存的值），所以被volatile修饰的变量能够保证每个线程能够获取该变量的最新值。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-05-08T09:19:52.930Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="volatile关键字详解">
<meta name="twitter:description" content="简介 volatile的本义是易变的、不稳定的。volatile关键字修饰的变量随时可能被其他线程修改。当volatile变量的值被修改时，主存中值的更新会使缓存中的值失效（非volatile变量不具备这样的特性，非volatile变量的值会被缓存，线程A更新了该值，但线程B读到的值可能并不是最新的值，而是缓存的值），所以被volatile修饰的变量能够保证每个线程能够获取该变量的最新值。">





  
  
  <link rel="canonical" href="https://mrfzh.github.io/2019/05/08/volatile关键字详解/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>volatile关键字详解 | FengZH的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FengZH的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://mrfzh.github.io/2019/05/08/volatile关键字详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FengZH">
      <meta itemprop="description" content="阳光总在风雨后！坚持就是胜利！">
      <meta itemprop="image" content="https://i.ibb.co/ZNQVBbd/head-Image1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FengZH的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">volatile关键字详解

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-08 17:17:18 / 修改时间：17:19:52" itemprop="dateCreated datePublished" datetime="2019-05-08T17:17:18+08:00">2019-05-08</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>volatile的本义是易变的、不稳定的。volatile关键字修饰的变量随时可能被其他线程修改。当volatile变量的值被修改时，主存中值的更新会使缓存中的值失效（非volatile变量不具备这样的特性，非volatile变量的值会被缓存，线程A更新了该值，但线程B读到的值可能并不是最新的值，而是缓存的值），所以<strong>被volatile修饰的变量能够保证每个线程能够获取该变量的最新值</strong>。</li>
</ul>
<a id="more"></a>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>volatile具有<strong>可见性</strong>、<strong>有序性</strong>，不具备原子性。</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>在了解各种特性前，需要知道Java的内存模型。</p>
<p>Java内存模型规定所有的变量都要存储在<strong>主内存</strong>中，而每个线程都拥有属于自己的<strong>工作内存</strong>，线程的工作内存中保存了该线程所使用到的变量（这些变量是从主内存拷贝而来）。线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，不同线程之间也无法访问对方工作内存中的变量，<strong>线程间变量值的传递均需要通过主内存来完成</strong>。  </p>
<p>因为这种内存模型，便产生了多线程编程中的<strong>数据脏读</strong>等问题。例如执行下面程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">": a = "</span> + a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VolatileTest volatileTest = <span class="keyword">new</span> VolatileTest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    volatileTest.add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"Thread A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    volatileTest.add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"Thread B"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中一次的结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread B: a = 2</span><br><span class="line">Thread A: a = 1</span><br><span class="line">Thread B: a = 3</span><br><span class="line">Thread A: a = 4</span><br><span class="line">Thread B: a = 5</span><br><span class="line">Thread B: a = 7</span><br><span class="line">Thread B: a = 8</span><br><span class="line">Thread B: a = 9</span><br><span class="line">Thread B: a = 10</span><br><span class="line">Thread B: a = 11</span><br><span class="line">Thread B: a = 12</span><br><span class="line">Thread B: a = 13</span><br><span class="line">Thread A: a = 6</span><br><span class="line">Thread A: a = 14</span><br><span class="line">Thread A: a = 15</span><br><span class="line">Thread A: a = 16</span><br><span class="line">Thread A: a = 17</span><br><span class="line">Thread A: a = 18</span><br><span class="line">Thread A: a = 19</span><br><span class="line">Thread A: a = 20</span><br></pre></td></tr></table></figure></p>
<p>可以看出线程读取到的结果可能不是最新的</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>原子性：指一个操作或者多个操作要么<strong>全部执行</strong>并且执行的过程不会被任何因素打断，要么就<strong>都不执行</strong>。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ol>
<li>生活上一个很经典的例子：<strong>银行转账问题</strong>。比如账户A向账户B转1000元，该事件包含两个操作：从账户A减去1000元，往账户B增加1000元。如果这两个操作不具备原子性，会出现什么问题呢？可能账户A减少了1000元，但是这时操作突然停止了。这样就会造成账户A的钱没有了，但账户B没有收到钱的问题。所以这两个操作必须具备原子性才能保证不出现意外。</li>
<li>在并发编程中，假设在线程A中执行赋值语句i = 10，暂且假设为一个32位的变量赋值包含两个操作：为低16位赋值，为高16位赋值。那么如果这两个操作不具备原子性，就有可能刚为低16位赋完值，线程A突然被中断，此时线程B要读这个值，那么线程B读取到的值就是错误的。所以这两个操作也必须具备原子性才能保证不出现意外。</li>
</ol>
<h3 id="Java中的原子性"><a href="#Java中的原子性" class="headerlink" title="Java中的原子性"></a>Java中的原子性</h3><p>在Java中，原子性操作包括：    </p>
<p>（1）对基本数据类型变量的<strong>读取</strong>和<strong>赋值</strong>（而且<strong>必须是将数字赋给某个变量</strong>，变量之间的相互赋值不是原子操作）操作。  </p>
<p>例如，对于下面的操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">x = <span class="number">10</span>;         <span class="comment">//(1)，是原子性操作</span></span><br><span class="line">y = x;          <span class="comment">//(2)，不是原子性操作</span></span><br><span class="line">x = x + <span class="number">1</span>;      <span class="comment">//(3)，不是原子性操作</span></span><br></pre></td></tr></table></figure></p>
<p>只有（1）是原子性操作，因为（1）是将数字赋给某个变量。（2）包含两个操作：读取x，将x赋给y。虽然两个操作都是原子操作，但合起来就不是原子操作了。（3）包含了三个操作：读取x，进行加1操作，将新的值赋给y，同理，并不是原子操作。  </p>
<p>如果要实现更大范围的原子性，可以通过synchronized和Lock来实现，synchronized和Lock保证了同一时刻只能由一个线程执行代码块，自热就保证了原子性。</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>可见性：当多个线程访问同一个变量时，假如线程1修改了该变量，其他线程能够立即读取到线程1修改后的变量的值。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>由于Java的内存模型，导致了一些可见性问题。例如某个共享变量一开始在主内存中的值是10，该值拷贝到了每个线程的工作内存中。线程A修改该值为15，并将其加载到线程A的工作内存中。此时线程B要读取该值，但它读取到的值仍为10，因为线程A修改后的值还没有写入主内存，或者即使线程A已经将修改后的值写入主内存，但线程B的工作内存还没有向主内存拷贝该值的话，线程B的工作内存中的值就还是旧的10。</p>
<h3 id="Java中的可见性"><a href="#Java中的可见性" class="headerlink" title="Java中的可见性"></a>Java中的可见性</h3><ul>
<li>Java提供了volatile关键字来保证可见性。对于被volatile修饰的变量，在变量修改后会立即更新到主存，并且当其他线程读取该值时，也会去主存中读取新值。（而普通变量无法保证可见性）</li>
<li>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且<strong>在释放锁之前会将对变量的修改刷新到主存当中</strong>，因此保证了可见性。</li>
</ul>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>有序性：程序执行时按照代码书写的先后顺序执行。在Java内存模型中，允许编译器和处理器对指令进行<strong>重排序</strong>，重排序并不会影响单线程的执行，却会影响多线程并发执行的正确性。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>举个简单的例子，看下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x, y;</span><br><span class="line">x = 10;         //语句1</span><br><span class="line">y = 20;         //语句2</span><br></pre></td></tr></table></figure></p>
<p>可以看到，语句1是在语句2前面的，那么JVM在真正执行的时候也会保证语句1在语句2前面吗？不一定。因为这里可能发生<strong>指令重排序</strong>。什么是指令重排序？  </p>
<blockquote>
<p>一般来说，处理器为了提高运行效率，可能会对输入代码进行优化，它<strong>不保证程序中各个语句的执行顺序会同代码顺序一样</strong>，但它会<strong>保证程序最终的执行结果和代码顺序执行的结果是一样的</strong>。</p>
</blockquote>
<p>然而，需要注意的是，<strong>虽然指令重排序不会影响当个程序的执行，但是它会影响多线程并发执行的正确性</strong>。看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line"></span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"></span><br><span class="line"> //线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">   sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingWithContext(context);    //语句3</span><br></pre></td></tr></table></figure>
<p>假如线程1先执行了语句2，然而在线程1还没执行语句1时，线程2却以为已经准备好了就跳出了循环，开始执行语句3，此时由于context还没有初始化，就可能会导致程序出错。</p>
<h3 id="Java中的有序性"><a href="#Java中的有序性" class="headerlink" title="Java中的有序性"></a>Java中的有序性</h3><ul>
<li>在Java中，可以通过volatile关键字来保证一定的有序性，或者通过synchronized和Lock来保证有序性。</li>
<li>Java内存模型具备一些先天的有序性，即不需要通过任何手段就能够得到保证的有序性，这个通常也被称为<strong>happens-before原则</strong>。如果两个操作的执行次序无法从happens-before原则推导出来，那么就不能保证它们的有序性，JVM可以随意地对它们进行重排序。</li>
</ul>
<h4 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h4><p>下面就来介绍下happens-before原则（先行发生原则）：</p>
<ol>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作（这个原则只能保证在单线程下的程序结果和代码顺序执行的结果一致，并不能保证在多线程下执行的正确性）</li>
<li>锁定规则：一个unLock操作先行发生于位于后面的对同一个锁的lock操作（也就是说对于同一个锁，如果该锁处于锁定状态，必须先释放该锁才能再次进行锁定操作）</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作（如果在代码中一个线程先去写一个变量，然后另一个线程再去读取，那么写入操作肯定会先行发生于读取操作）</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束，通过Thread.isAlive()的返回值手段检测到线程是否已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>
</ol>
<h2 id="valotile如何确保可见性"><a href="#valotile如何确保可见性" class="headerlink" title="valotile如何确保可见性"></a>valotile如何确保可见性</h2><p>前面说过valotile关键性修饰的变量是保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了该变量，其他线程能够立即知道这种改变。  </p>
<p>那么valotile是如何保证这种可见性的呢？  </p>
<p>在生成汇编代码时，valotile修饰的变量在进行写操作时会多出<strong>Lock前缀的指令</strong>，这个指令在多核处理器下主要有这两个方面的影响：</p>
<ol>
<li>将当前处理器缓存行的数据写回系统内存</li>
<li>其他CPU缓存了该内存地址的数据无效  </li>
</ol>
<p>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现<strong>缓存一致性</strong>协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将该缓存行设置成<strong>无效状态</strong>。</p>
<p>所以使用valotile修饰的变量A被修改后的过程如下：</p>
<ol>
<li>当线程1修改了A后，修改后的值会立即写入主存中，并导致其它线程的工作内存中缓存该变量A的缓存行失效。</li>
<li>当其他线程，例如线程2读取变量A的时候，发现其工作内存中变量A的缓存行失效，线程2就会去主存中读取变量A，这样读取到的值就是最新的。</li>
</ol>
<h2 id="valotile如何确保有序性"><a href="#valotile如何确保有序性" class="headerlink" title="valotile如何确保有序性"></a>valotile如何确保有序性</h2><p>由于valotile关键字能禁止指令重排列，所以valotile能在<strong>一定程度上</strong>保证有序性。</p>
<p><strong>Lock前缀指令</strong>实际上相当于一个<strong>内存屏障（也成内存栅栏）</strong>，它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p>
<p>valotile关键字禁止指令重排列有两层意思：</p>
<ol>
<li>当程序执行到valotile变量的读操作或写操作的时候，在<strong>其前面的操作肯定已经全部进行</strong>，并且<strong>结果对后面的操作可见</strong>；在其<strong>后面的操作肯定还没有进行</strong>。</li>
<li>在进行指令优化时，不能将valotile变量前面的语句放到其后面执行，也不能将valotile变量后面的语句放到前面执行。</li>
</ol>
<p>举个的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//假设x，y是普通变量，flag是volatile变量</span><br><span class="line"></span><br><span class="line">x = 10;     //语句1</span><br><span class="line">y = 15;     //语句2</span><br><span class="line">flag = 20;  //语句3</span><br><span class="line">x = 25;     //语句4</span><br><span class="line">y = 30;     //语句5</span><br></pre></td></tr></table></figure></p>
<p>由于valotile的有序性，所以语句3一定是在语句1和语句2之后进行，并且语句1和语句2的结果对语句3可见，而语句4和语句5会在语句3之后进行。但语句1和语句2哪个先执行是不确定的，语句4和语句5同理。</p>
<p>对于之前的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"></span><br><span class="line"> //线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">   sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingWithContext(context);    //语句3</span><br></pre></td></tr></table></figure></p>
<p>假如inited是valotile变量，那么就可以保证执行到语句2时，语句1已经执行完毕，并且语句1的结果可见，那么语句3就肯定不会出现问题了。</p>
<h2 id="valotile不能确保原子性"><a href="#valotile不能确保原子性" class="headerlink" title="valotile不能确保原子性"></a>valotile不能确保原子性</h2><p>先看一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VolatileTest volatileTest = <span class="keyword">new</span> VolatileTest();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;</span><br><span class="line">                        volatileTest.increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;  <span class="comment">//保证前面的线程全部执行完毕</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(volatileTest.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例子中新建了10个线程，每个线程自增1w次，那么输出结果应该是10w才对。但运行多次后发现，有时候结果是10w，但有时候可能只有9w多。  </p>
<p>为什么会这样呢？volatile确实可以保证可见性。但问题是出在自增操作上，自增操作并不是原子操作，volatile<strong>无法保证对volatile变量的任何操作都是原子性的</strong>。 </p>
<p>假如某个时刻变量num的值为10，此时线程1对变量进行自增操作，线程1先读取了变量num的值，然后线程1被阻塞了；</p>
<p>换成线程2对变量进行自增操作，线程2也去读取变量num的值，由于线程1只是对变量进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中变量num的缓存行无效，也不会导致主存中的值刷新，所以线程2读取到的值也是10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>然后线程1接着进行加1操作，由于之前已经读取了num的值，所以现在直接进行加1和赋值操作，然后将11写入工作内存，最后写入主存。</p>
<p>可以看到两个线程都进行了一次自增操作，但num只增加了1。</p>
<p>那怎么解决这个问题呢？</p>
<ol>
<li><p>可以通过synchronized或Lock进行<strong>加锁</strong>，来保证自增操作的原子性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<strong>原子操作类</strong>（在java.util.concurrent.atomic包下），保证自增操作的原子性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger num = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    num.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>volatile在某些时候性能是由于synchronized的，但是volatile并不能替代synchronized，因为volatile无法保证操作的原子性。使用volatile变量必须具备以下两个条件：</p>
<ol>
<li>对变量的写操作不依赖与当前值（例如自增操作就不符合这个条件）</li>
<li>该变量没有包含在具有其他变量的不变式中</li>
</ol>
<p>下面列举几个使用volatile的场景</p>
<ol>
<li>状态标记量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"> <span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>线程1可根据状态标记，及时终止操作</p>
<ol start="2">
<li>Double Check Lock(DCL)实现单例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton sSingleton = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sSingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sSingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sSingleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>为什么要用volatile来修饰sSingleton呢？</p>
<p>原因在于sSingleton = new Singleton()这条语句，这条语句并不是一个原子操作，它大致做了以下这3件事：</p>
<ol>
<li>给sSingleton分配内存</li>
<li>调用Singleton的构造函数来初始化成员变量</li>
<li>将sSingleton对象指向分配的内存空间（执行完这一步后，sSingleton就不为null了）</li>
</ol>
<p>但是由于编译器的指令重排序，上面第2和第3步的顺序是不能保证的。最终的执行顺序可能是1-2-3也可能是1-3-2。如果是1-3-2，那么假如线程A刚好执行完3时（此时sSingleton不为null），切换到另一个线程B，线程B刚好执行到第一个if(sSingleton == null)判断语句（注意是第一个，线程B没有获得锁是执行不到第二个if判断的），此时由于sSingleton不为null，所以直接返回还没初始化的sSingleton，所以报错。</p>
<p>但是sSingleton如果用volatile修饰的话，由于<strong>volatile可以禁止指令重排序</strong>，此处是sSingleton的写操作，所以可以保证在写操作前的所有指令一定会在volatile写操作之前完成，那么也就<strong>保证了sSingleton = new Singleton()这条语句的执行顺序是1-2-3</strong>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://baijiahao.baidu.com/s?id=1595669808533077617&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">1分钟读懂java中的volatile关键字</a></li>
<li><a href="https://www.jianshu.com/p/7798161d7472" target="_blank" rel="noopener">你真的了解volatile关键字吗？</a></li>
<li><a href="https://www.jianshu.com/p/157279e6efdb" target="_blank" rel="noopener">让你彻底理解volatile</a></li>
<li><a href="https://blog.csdn.net/jm_heiyeqishi/article/details/51052889" target="_blank" rel="noopener">单例模式singleton为什么要加volatile</a></li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    
	
	<div>
	  
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------　　　　本文到此结束　<i class="fa fa-heart"></i>　感谢您的阅读　　　　-------------</div>
    
</div>

	  
	</div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/并发/" rel="tag"><i class="fa fa-tag"></i> 并发</a>
          
            <a href="/tags/线程/" rel="tag"><i class="fa fa-tag"></i> 线程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/06/利用KMP算法解决LeetCode第28题：实现strStr/" rel="next" title="利用KMP算法解决LeetCode第28题：实现strStr()">
                <i class="fa fa-chevron-left"></i> 利用KMP算法解决LeetCode第28题：实现strStr()
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/11/ConstraintLayout（约束布局）的使用/" rel="prev" title="ConstraintLayout（约束布局）的使用">
                ConstraintLayout（约束布局）的使用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://i.ibb.co/ZNQVBbd/head-Image1.jpg" alt="FengZH">
            
              <p class="site-author-name" itemprop="name">FengZH</p>
              <div class="site-description motion-element" itemprop="description">阳光总在风雨后！坚持就是胜利！</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Mrfzh" title="GitHub &rarr; https://github.com/Mrfzh" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:15521206029@163.com" title="E-Mail &rarr; mailto:15521206029@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#特性"><span class="nav-number">2.</span> <span class="nav-text">特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java内存模型"><span class="nav-number">2.1.</span> <span class="nav-text">Java内存模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子性"><span class="nav-number">2.2.</span> <span class="nav-text">原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">2.2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例"><span class="nav-number">2.2.2.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中的原子性"><span class="nav-number">2.2.3.</span> <span class="nav-text">Java中的原子性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可见性"><span class="nav-number">2.3.</span> <span class="nav-text">可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中的可见性"><span class="nav-number">2.3.3.</span> <span class="nav-text">Java中的可见性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有序性"><span class="nav-number">2.4.</span> <span class="nav-text">有序性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-2"><span class="nav-number">2.4.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例子"><span class="nav-number">2.4.2.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中的有序性"><span class="nav-number">2.4.3.</span> <span class="nav-text">Java中的有序性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#happens-before原则"><span class="nav-number">2.4.3.1.</span> <span class="nav-text">happens-before原则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#valotile如何确保可见性"><span class="nav-number">2.5.</span> <span class="nav-text">valotile如何确保可见性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#valotile如何确保有序性"><span class="nav-number">2.6.</span> <span class="nav-text">valotile如何确保有序性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#valotile不能确保原子性"><span class="nav-number">2.7.</span> <span class="nav-text">valotile不能确保原子性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#应用场景"><span class="nav-number">3.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">4.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FengZH</span>

  

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>



  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
