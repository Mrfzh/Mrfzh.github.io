<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/F-32x21.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/F-16x16.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.0',
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="阳光总在风雨后！坚持就是胜利！">
<meta property="og:type" content="website">
<meta property="og:title" content="FengZH的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="FengZH的博客">
<meta property="og:description" content="阳光总在风雨后！坚持就是胜利！">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FengZH的博客">
<meta name="twitter:description" content="阳光总在风雨后！坚持就是胜利！">





  
  
  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>FengZH的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FengZH的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/25/一些排序算法的实现（C语言）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FengZH">
      <meta itemprop="description" content="阳光总在风雨后！坚持就是胜利！">
      <meta itemprop="image" content="http://baocangwh.cn/t6/702/1556201512x2728278694.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FengZH的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/25/一些排序算法的实现（C语言）/" class="post-title-link" itemprop="url">一些排序算法的实现（C语言）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-25 22:02:28 / 修改时间：22:03:58" itemprop="dateCreated datePublished" datetime="2019-04-25T22:02:28+08:00">2019-04-25</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123; <span class="comment">//需要进行n-1轮冒泡</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++) &#123;   <span class="comment">//每一轮的比较</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(a, j, j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="鸡尾酒排序（双向冒泡排序）"><a href="#鸡尾酒排序（双向冒泡排序）" class="headerlink" title="鸡尾酒排序（双向冒泡排序）"></a>鸡尾酒排序（双向冒泡排序）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 鸡尾酒排序，设置标记位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CocktailSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> right = n<span class="number">-1</span>;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">bool</span> isSwaped = <span class="literal">false</span>;     <span class="comment">//设置标记位，标记上一次遍历数组时是否有交换</span></span><br><span class="line">                                <span class="comment">//如果没有交换的话就直接break，因为没有交换就说明已经排好序了</span></span><br><span class="line">     <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        isSwaped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = left; i &lt; right; i++) &#123;    <span class="comment">//先从左到右选出最大的</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                swap(a, i, i+<span class="number">1</span>);</span><br><span class="line">                isSwaped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isSwaped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        right--;</span><br><span class="line"></span><br><span class="line">        isSwaped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = right; i &gt; <span class="number">0</span>; i--) &#123;   <span class="comment">//再从右到左选出最小的</span></span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                swap(a, i, i<span class="number">-1</span>);</span><br><span class="line">                isSwaped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isSwaped) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, min;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; n; j++) &#123; <span class="comment">//一轮下来选出最小的元素的下标</span></span><br><span class="line">            <span class="keyword">if</span> (a[min] &gt; a[j]) &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != min) &#123;     <span class="comment">//如果最小的元素不是这轮的第一个，则交换</span></span><br><span class="line">            swap(a, i, min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认第一个数a[0]是有序的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//分析：从第二个数开始，每个数依次跟前面已排序序列从后往前比较，</span></span><br><span class="line">    <span class="comment">//若小于前面的数，则前面的数依次往后移位，直到大于前面的数，则放在前面的数的后一位</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> get = a[i];     <span class="comment">//先将拿到的数保存起来</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//若小于前面的数，则前面的数依次往后移位，直到大于前面的数</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; get) &#123;</span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放在前面的数的后一位</span></span><br><span class="line">        a[j+<span class="number">1</span>] = get;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 插入排序的改进：二分插入排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 二分插入排序：对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找来减少比较操作的次数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 比较：当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，</span></span><br><span class="line"><span class="comment"> * 所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。</span></span><br><span class="line"><span class="comment"> * 二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSortDichotomy</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> get = a[i];</span><br><span class="line">        <span class="comment">//已排序数组的左右边界</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[middle] &lt; get) &#123;  <span class="comment">//如果拿到的数大于中间数，则应放到后半部分</span></span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">//否则应放在左半部分（包括了等于中间数的情况）</span></span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行完循环后，拿到的数应放在left的位置（结果就是这样）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将所有大于get的数都往右移一位</span></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = i<span class="number">-1</span>; j &gt;= left; j--) &#123;</span><br><span class="line">            a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将get放到正确位置</span></span><br><span class="line">        a[left] = get;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 带有增量h的插入排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSortWithIncrement</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = h; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> get = a[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - h;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; a[j] &gt; get) &#123;</span><br><span class="line">            a[j+h] = a[j];</span><br><span class="line">            j = j - h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        a[j+h] = get;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 概述：希尔排序通过将比较的全部元素分为几个区域（第1,1+d,1+2d,...个元素为一组，d为增量）来提升插入排序的性能。</span></span><br><span class="line"><span class="comment"> * 这样可以让一个元素可以一次性地朝最终位置前进一大步。</span></span><br><span class="line"><span class="comment"> * 然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，这时需排序的数据几乎是已排好的了（此时插入排序较快）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt;= n)&#123;                          <span class="comment">// 生成初始增量</span></span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        InsertionSortWithIncrement(A, n, h);    <span class="comment">//进行一次增量为h的插入排序，当h为1时就是普通的插入排序</span></span><br><span class="line">        h = (h - <span class="number">1</span>) / <span class="number">3</span>;                    <span class="comment">// 递减增量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 进行一趟快排，返回基准索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[right];     <span class="comment">//选择最后一个元素作为基准</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = right;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">//如果选中第一个元素为基准，应先进行减操作，即将下面两个while循环换个位置</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[left] &lt;= pivot) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; a[right] &gt;= pivot) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, left, pivotIndex);      <span class="comment">//将基准回归到正确位置（left也可换成right，因为此时left == right）</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * 对于Partition有多种算法，可参考：https://blog.csdn.net/qq_36528114/article/details/78667034</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pivotIndex = Partition(a, left, right);   <span class="comment">//进行一趟排序后获得基准的索引</span></span><br><span class="line">    QuickSort(a, left, pivotIndex<span class="number">-1</span>);</span><br><span class="line">    QuickSort(a, pivotIndex+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 合并两个已经排好序的数组a[left...mid]和a[mid+1...right]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span> temp[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left;   <span class="comment">//第一个数组开头位标</span></span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;    <span class="comment">//第二个数组开头位标</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较两数组元素大小</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        temp[k++] = a[i] &lt;= a[j] ? a[i++] : a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将剩余未比较的元素放入temp数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[k++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        temp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将temp数组（已排好序）赋给数组a</span></span><br><span class="line">    <span class="keyword">int</span> len = right - left + <span class="number">1</span>;     <span class="comment">//合并后的数字长度，注意：这里必须先存起来，因为循环体中的赋值操作改变了left</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; len; k++) &#123;</span><br><span class="line">        a[left++] = temp[k];    <span class="comment">//注意：是从a[left]开始赋值，而不是a[0]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> temp[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    MergeSort(a, left, mid, temp);</span><br><span class="line">    MergeSort(a, mid+<span class="number">1</span>, right, temp);</span><br><span class="line">    <span class="comment">//合并两个已排好序的子数组</span></span><br><span class="line">    Merge(a, left, mid, right, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 调整为大顶堆（从a[i]开始调整）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a[i];    <span class="comment">//保存a[i];</span></span><br><span class="line">    <span class="keyword">int</span> k;  <span class="comment">//k用于存储子节点</span></span><br><span class="line">    <span class="keyword">for</span> (k = i*<span class="number">2</span> + <span class="number">1</span>; k &lt; length; k = k*<span class="number">2</span> + <span class="number">1</span>) &#123;    <span class="comment">//从i节点的左子节点开始</span></span><br><span class="line">        <span class="keyword">if</span> (k+<span class="number">1</span> &lt; length &amp;&amp; a[k] &lt; a[k+<span class="number">1</span>]) &#123;    <span class="comment">//如果左子节点小于右子节点，则k指向右子节点</span></span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[k] &gt; temp) &#123;  <span class="comment">//如果子节点大于父节点，将子节点赋给父节点（不用进行交换，子节点的值暂时是temp）</span></span><br><span class="line">            a[i] = a[k];</span><br><span class="line">            i = k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//否则退出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">    a[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 建堆（大顶堆）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BuildHeap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//从最后一个非叶子节点开始进行堆调整</span></span><br><span class="line">         adjustHeap(a, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> * 1. 将无序序列构建成一个堆，升序选择大顶堆，降序选择小顶堆;</span></span><br><span class="line"><span class="comment"> * 2. 将堆顶元素与末尾元素交换，将最大元素沉到数组末端</span></span><br><span class="line"><span class="comment"> * 3. 重新调整堆结构，然后继续将堆顶元素与末尾元素交换，重复这个过程，直到整个序列有序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先构建大顶堆</span></span><br><span class="line">    BuildHeap(a, n);</span><br><span class="line">    <span class="comment">//调整堆结构</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(a, <span class="number">0</span>, i);  <span class="comment">//交换堆顶元素和末尾元素</span></span><br><span class="line">        adjustHeap(a, <span class="number">0</span>, i);    <span class="comment">//重新对堆进行排序（不包括已交换到末尾排序好的元素）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">21</span>, <span class="number">11</span>, <span class="number">48</span>, <span class="number">6</span>, <span class="number">92</span>, <span class="number">41</span>, <span class="number">39</span>, <span class="number">77</span>, <span class="number">20</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">int</span> temp[n];  <span class="comment">//在外面开辟一个临时数组(可重复利用)，避免在归并的递归操作中多次开辟空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//BubbleSort(a, n);</span></span><br><span class="line">    <span class="comment">//CocktailSort(a, n);</span></span><br><span class="line">    <span class="comment">//SelectionSort(a, n);</span></span><br><span class="line">    <span class="comment">//InsertionSort(a, n);</span></span><br><span class="line">    <span class="comment">//InsertionSortDichotomy(a, n);</span></span><br><span class="line">    <span class="comment">//ShellSort(a, n);</span></span><br><span class="line">    <span class="comment">//QuickSort(a, 0, n-1);</span></span><br><span class="line">    <span class="comment">//MergeSort(a, 0, n-1, temp);</span></span><br><span class="line">    HeapSort(a, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);    <span class="comment">//正确答案为：1 6 11 20 21 39 41 48 77 92</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://www.cnblogs.com/eniac12/p/5329396.html#s6" target="_blank" rel="noopener">常用排序算法总结(一)</a></li>
<li><a href="https://blog.csdn.net/qq_36528114/article/details/78667034" target="_blank" rel="noopener">快速排序(三种算法实现和非递归实现)</a></li>
<li><a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">图解排序算法(四)之归并排序</a></li>
<li><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">图解排序算法(三)之堆排序</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    
	
	<div>
	  
	</div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/24/源码分析：Activity的启动过程（1）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FengZH">
      <meta itemprop="description" content="阳光总在风雨后！坚持就是胜利！">
      <meta itemprop="image" content="http://baocangwh.cn/t6/702/1556201512x2728278694.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FengZH的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/24/源码分析：Activity的启动过程（1）/" class="post-title-link" itemprop="url">源码分析：Activity的启动过程（1）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-24 22:43:46 / 修改时间：22:49:12" itemprop="dateCreated datePublished" datetime="2019-04-24T22:43:46+08:00">2019-04-24</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Activity-startActivityForResult"><a href="#Activity-startActivityForResult" class="headerlink" title="Activity#startActivityForResult"></a>Activity#startActivityForResult</h1><p>我们从Activity的startActivity方法开始分析，该方法有几种重载方式，但最终都会调用startActivityForResult方法，该方法实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;	<span class="comment">//只需关注这部分代码</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">			</span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">            mInstrumentation.execStartActivity(</span><br><span class="line">                <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                intent, requestCode, options);     <span class="comment">//先看Instrumentation的execStartActivity方法（exec是execute的缩写，意为执行）</span></span><br><span class="line">			</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看下Instrumentation的execStartActivity方法</p>
<h1 id="Instrumentation-execStartActivity（API25）"><a href="#Instrumentation-execStartActivity（API25）" class="headerlink" title="Instrumentation#execStartActivity（API25）"></a>Instrumentation#execStartActivity（API25）</h1><ul>
<li>Instrumentation类相当于一个管家，它的职责是管理各个应用程序和系统的交互，Instrumentation将在任何应用程序运行前初始化，每个进程只会存在一个Instrumentation对象，且每个Activity都有此对象的实际引用，可以通过它监测系统与应用程序之间的所有交互。</li>
<li>这里可以看到真正启动Activity的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        </span><br><span class="line">	<span class="comment">//真正启动Activity</span></span><br><span class="line">        <span class="keyword">int</span> result = ActivityManagerNative.getDefault()		<span class="comment">//ActivityManagerNative.getDefault()返回一个IActivityManager接口对象</span></span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">                    </span><br><span class="line">        <span class="comment">//检查启动结果，当无法正确启动时会抛出异常信息            </span></span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中，IActivityManager接口的具体实现是ActivityManagerService（下面简称AMS）。AMS继承自ActivityManagerNative，而ActivityManagerNative继承自Binder并实现了IActivityManager，所以AMB也是一个Binder。不过在API26中，AMS不再继承AMN，而是继承IActivityManager.Stub。（注意：在API26中，AMN被弃用，其内部的代理类ActivityManagerProxy已经被删除。这是因为在API26启动Activity的时候，和AMS的通信机制已经被改成AIDL方式，<a href="https://blog.csdn.net/qi1017269990/article/details/78879512" target="_blank" rel="noopener">详情请参考该博客</a>）</li>
</ul>
<h2 id="ActivityManagerNative-getDefault"><a href="#ActivityManagerNative-getDefault" class="headerlink" title="ActivityManagerNative.getDefault()"></a>ActivityManagerNative.getDefault()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gDefault.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中gDefault的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);</span><br><span class="line">        IActivityManager am = asInterface(b);</span><br><span class="line">        <span class="keyword">return</span> am;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Singleton是一个单例的封装类，第一次调用它的get方法时它会通过create方法来创建对象，在后续的调用中则直接返回之前创建的对象。</p>
<h1 id="Instrumentation-execStartActivity（API26）"><a href="#Instrumentation-execStartActivity（API26）" class="headerlink" title="Instrumentation#execStartActivity（API26）"></a>Instrumentation#execStartActivity（API26）</h1><p>在API26中，真正启动Activity的代码发生了一些变化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ActivityManager.getService()返回 IActivityManager对象</span></span><br><span class="line">   <span class="keyword">int</span> result = ActivityManager.getService()</span><br><span class="line">       .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">               intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">               token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">               requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br></pre></td></tr></table></figure></p>
<h2 id="ActivityManager-getService"><a href="#ActivityManager-getService" class="headerlink" title="ActivityManager.getService()"></a>ActivityManager.getService()</h2><p>看下ActivityManager.getService()返回的是什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IActivityManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IActivityManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">        <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                <span class="comment">//其中，Context.ACTIVITY_SERVICE = "activity";</span></span><br><span class="line">                <span class="keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                <span class="keyword">return</span> am;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，高低版本都是先获取服务端（系统进程）中的AMS的IBinder对象，然后通过得到的IBinder对象来生成IActivityManager（系统进程中的AMS在app进程中的binder代理）</p>
<h1 id="ActivityManagerService-startActivity"><a href="#ActivityManagerService-startActivity" class="headerlink" title="ActivityManagerService#startActivity"></a>ActivityManagerService#startActivity</h1><p>虽然不同版本的实现有所不同，但最终都是返回IActivityManager接口对象，而IActivityManager接口的实现类为AMS，所以最终调用的是AMS的startActivity方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.</span></span><br><span class="line">    <span class="keyword">return</span> mActivityStarter.startActivityMayWait(caller, -<span class="number">1</span>, callingPackage, intent,</span><br><span class="line">            resolvedType, <span class="keyword">null</span>, <span class="keyword">null</span>, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">            profilerInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, bOptions, <span class="keyword">false</span>, userId, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中mActivityStarter是一个ActivityStarter对象，ActivityStarter类主要负责处理Activity的Intent和Flags, 还有关联相关的Stack和TaskRecord。</li>
<li>在API23及以前版本中，return那里是调用ActivityStackSupervisor的startActivityMayWait方法的（该方法的实现和ActivityStarter一样，不如说是ActivityStarter照搬该方法）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> mStackSupervisor.startActivityMayWait(caller, -<span class="number">1</span>, callingPackage, intent,</span><br><span class="line">        resolvedType, <span class="keyword">null</span>, <span class="keyword">null</span>, resultTo, resultWho, requestCode, startFlags,</span><br><span class="line">        profilerInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, options, <span class="keyword">false</span>, userId, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>但是在API24中，ActivityStackSupervisor移除了startActivityMayWait方法，该方法到了ActivityStarter中。</p>
<h1 id="又继续调用了几个方法"><a href="#又继续调用了几个方法" class="headerlink" title="又继续调用了几个方法"></a>又继续调用了几个方法</h1><h2 id="ActivityStarter-startActivityMayWait"><a href="#ActivityStarter-startActivityMayWait" class="headerlink" title="ActivityStarter#startActivityMayWait"></a>ActivityStarter#startActivityMayWait</h2><ul>
<li>startActivityMayWait: 根据Intent获取Activity的启动信息(ResolveInfo和ActivityInfo), 获取调用者的Pid和Uid（CallingPid和CallingUid）</li>
<li>startActivityMayWait继续调用startActivityLocked方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">int</span> res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">        aInfo, rInfo, voiceSession, voiceInteractor,</span><br><span class="line">        resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">        callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">        options, ignoreTargetSecurity, componentSpecified, outRecord, container,</span><br><span class="line">        inTask);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="ActivityStarter-startActivityLocked"><a href="#ActivityStarter-startActivityLocked" class="headerlink" title="ActivityStarter#startActivityLocked"></a>ActivityStarter#startActivityLocked</h2><ul>
<li>startActivityLocked: 创建ActivityRecord, 含有Activity的核心信息</li>
<li>startActivityLocked继续调用startActivityUnchecked方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//...</span><br><span class="line">try &#123;</span><br><span class="line">    //...</span><br><span class="line">    err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">            true, options, inTask);</span><br><span class="line">&#125; </span><br><span class="line">//...</span><br><span class="line">return err;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="ActivityStarter-startActivityUnchecked"><a href="#ActivityStarter-startActivityUnchecked" class="headerlink" title="ActivityStarter#startActivityUnchecked"></a>ActivityStarter#startActivityUnchecked</h2><ul>
<li>startActivityUnchecked：根据启动的Flag信息, 设置TaskRecord, 完成后执行ActivityStackSupervisor类的resumeFocusedStackTopActivityLocked方法, 继续启动。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//...</span><br><span class="line"></span><br><span class="line">// 所有启动准备完成后, dontStart是true.</span><br><span class="line">final boolean dontStart = top != null &amp;&amp; mStartActivity.resultTo == null</span><br><span class="line">        &amp;&amp; top.realActivity.equals(mStartActivity.realActivity)</span><br><span class="line">        &amp;&amp; top.userId == mStartActivity.userId</span><br><span class="line">        &amp;&amp; top.app != null &amp;&amp; top.app.thread != null</span><br><span class="line">        &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != 0</span><br><span class="line">        || mLaunchSingleTop || mLaunchSingleTask);</span><br><span class="line">if (dontStart) &#123;</span><br><span class="line">    //...</span><br><span class="line">    if (mDoResume) &#123;</span><br><span class="line">        mSupervisor.resumeFocusedStackTopActivityLocked();  //mSupervisor是一个ActivityStackSupervisor对象</span><br><span class="line">    &#125;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="ActivityStackSupervisor和ActivityStack之间的相互跳转"><a href="#ActivityStackSupervisor和ActivityStack之间的相互跳转" class="headerlink" title="ActivityStackSupervisor和ActivityStack之间的相互跳转"></a>ActivityStackSupervisor和ActivityStack之间的相互跳转</h1><h2 id="ActivityStackSupervisor-resumeFocusedStackTopActivityLocked"><a href="#ActivityStackSupervisor-resumeFocusedStackTopActivityLocked" class="headerlink" title="ActivityStackSupervisor#resumeFocusedStackTopActivityLocked"></a>ActivityStackSupervisor#resumeFocusedStackTopActivityLocked</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeFocusedStackTopActivityLocked() &#123;</span><br><span class="line">    return resumeFocusedStackTopActivityLocked(null, null, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean resumeFocusedStackTopActivityLocked(</span><br><span class="line">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123;</span><br><span class="line">    if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">        return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">        //targetStack是一个ActivityStack对象</span><br><span class="line">    &#125;</span><br><span class="line">    final ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class="line">    if (r == null || r.state != RESUMED) &#123;</span><br><span class="line">        mFocusedStack.resumeTopActivityUncheckedLocked(null, null); //mFocusedStack也是一个ActivityStack对象</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又调用了ActivityStack的resumeTopActivityUncheckedLocked方法</p>
<h2 id="ActivityStack-resumeTopActivityUncheckedLocked"><a href="#ActivityStack-resumeTopActivityUncheckedLocked" class="headerlink" title="ActivityStack#resumeTopActivityUncheckedLocked"></a>ActivityStack#resumeTopActivityUncheckedLocked</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123;</span><br><span class="line">    if (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">        // Don&apos;t even start recursing.</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean result = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        // Protect against recursion.</span><br><span class="line">        mStackSupervisor.inResumeTopActivity = true;</span><br><span class="line">        if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) &#123;</span><br><span class="line">            mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN;</span><br><span class="line">            mService.updateSleepIfNeededLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options);	//调用resumeTopActivityInnerLocked方法</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mStackSupervisor.inResumeTopActivity = false;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后返回的result的值是通过调用resumeTopActivityInnerLocked方法获得的</p>
<h2 id="ActivityStack-resumeTopActivityInnerLocked"><a href="#ActivityStack-resumeTopActivityInnerLocked" class="headerlink" title="ActivityStack#resumeTopActivityInnerLocked"></a>ActivityStack#resumeTopActivityInnerLocked</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mStackSupervisor.startSpecificActivityLocked(next, true, false);    </span><br><span class="line">//mStackSupervisor是一个ActivityStackSupervisor对象</span><br></pre></td></tr></table></figure>
<p>又调用了ActivityStackSupervisor的startSpecificActivityLocked方法</p>
<h2 id="ActivityStackSupervisor-startSpecificActivityLocked"><a href="#ActivityStackSupervisor-startSpecificActivityLocked" class="headerlink" title="ActivityStackSupervisor#startSpecificActivityLocked"></a>ActivityStackSupervisor#startSpecificActivityLocked</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void startSpecificActivityLocked(ActivityRecord r,</span><br><span class="line">        boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">    // Is this activity&apos;s application already running?</span><br><span class="line">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">            r.info.applicationInfo.uid, true);</span><br><span class="line"></span><br><span class="line">    r.task.stack.setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">    if (app != null &amp;&amp; app.thread != null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //...</span><br><span class="line">            </span><br><span class="line">            //真正启动activity的过程</span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">            return;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            //...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于，这里调用了realStartActivityLocked方法真正启动activity</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《Android开发艺术探索》</li>
<li><a href="https://www.jianshu.com/p/86ad1026cef3" target="_blank" rel="noopener">Android 7.0 startActivity()源码解析以及对几个问题的思考</a></li>
<li><a href="https://www.jianshu.com/p/dc6b0ead30aa" target="_blank" rel="noopener">源码分析:startActivity流程</a></li>
<li><a href="https://www.jianshu.com/p/269e3dc06b09" target="_blank" rel="noopener">探索7.x, 全面解析Activity启动框架 (1)</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    
	
	<div>
	  
	</div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/23/线程笔记（4）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FengZH">
      <meta itemprop="description" content="阳光总在风雨后！坚持就是胜利！">
      <meta itemprop="image" content="http://baocangwh.cn/t6/702/1556201512x2728278694.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FengZH的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/23/线程笔记（4）/" class="post-title-link" itemprop="url">线程笔记（4）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-23 22:20:01 / 修改时间：22:20:45" itemprop="dateCreated datePublished" datetime="2019-04-23T22:20:01+08:00">2019-04-23</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java笔记/" itemprop="url" rel="index"><span itemprop="name">java笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><ul>
<li>简介：线程池在系统启动时即创建大量空闲的线程，程序将一个Runnable对象或者Callable对象传给线程池，线程池就会启动一个线程来执行它们的run或call方法，当run或call方法执行结束后，该线程<strong>并不会死亡</strong>，而是再次返回线程池中成为空闲状态，等待下一个Runnable或Callable对象。</li>
<li>作用：使用线程池可以有效地控制系统中并发线程的数量，当系统中包含大量并发线程时，会导致系统性能剧烈下降，甚至导致JVM崩溃，而线程池的最大线程数可以控制系统中的并发线程数不超过此数。</li>
</ul>
<h2 id="Executors、Executor和ExecutorService"><a href="#Executors、Executor和ExecutorService" class="headerlink" title="Executors、Executor和ExecutorService"></a>Executors、Executor和ExecutorService</h2><p>Executors是一个工厂类，包含了一些静态方法来创建线程池；Executor是一个接口，它是ExecutorService接口的父接口（类似Collections和Collection）</p>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个具有固定线程数的线程池</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//创建一个Runnable对象</span></span><br><span class="line">        Runnable target = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"的i = "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//向线程池中提交两个线程</span></span><br><span class="line">        pool.submit(target);</span><br><span class="line">        pool.submit(target);</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Executors创建线程池的几种方式"><a href="#Executors创建线程池的几种方式" class="headerlink" title="Executors创建线程池的几种方式"></a>Executors创建线程池的几种方式</h2><ol>
<li>newCachedThreadPool()：创建一个具有缓存功能的线程池，该线程池没有长度限制，对于新的任务，如果有空闲的线程，则使用空闲的线程执行，如果没有，则新建一个线程来执行任务。如果线程池长度超过处理需要，可灵活回收空闲线程。</li>
<li><p>newFixedThreadPool(int nThreads)：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。定长线程池的大小通常根据系统资源进行设置：Runtime.getRuntime().availableProcessors()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br></pre></td></tr></table></figure>
</li>
<li><p>newSingleThreadScheduledExecutor()：创建一个只有单个线程的线程池，它相当于调用newFixedThreadPool方法时传入参数为1。</p>
</li>
<li>newScheduledThreadPool(int corePoolSize)：创建一个定长线程池，并且支持定时和周期性的执行任务。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(<span class="number">10</span>);  </span><br><span class="line">scheduledPool.schedule(target, <span class="number">10</span>, TimeUnit.SECONDS);   <span class="comment">//延迟8秒执行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">scheduledPool.scheduleAtFixedRate(target, <span class="number">10</span>, <span class="number">5</span>, TimeUnit.SECONDS); <span class="comment">//延迟10s执行，每5s执行一次</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//第一次延迟10s执行，随后在每一次执行结束和下一次执行开始之间的间隔为5s</span></span><br><span class="line">scheduledPool.scheduleWithFixedDelay(target, <span class="number">10</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>newSingleThreadScheduledExecutor()：创建一个只有单个线程的线程池，并且支持定时和周期性地执行任务。</li>
<li>newWorkStealingPool(int parallelism)：创建持有足够线程的线程池来支持给定的并行级别（parallelism），该方法还会使用多个队列来减少竞争。</li>
<li>newWorkStealingPool()：该方法相当于前一个方法传入参数Runtime.getRuntime().availableProcessors()，即如果当前机器有4个CPU，则传入4。</li>
</ol>
<ul>
<li>方法总结<ul>
<li>上述各个方法，除了最后两个，其他的方法都有另一个具有ThreadFactory threadFactory参数的重载方法，该参数的作用是定义如何启动一个线程，可以设置线程的名称，并且可以确定是否是后台线程等。</li>
<li>最后两个方法是Java8新增的，这两个方法充分利用多CPU并行的能力，这两个方法生成的work stealing池，都相当于后台线程池，如果所有的前台线程都死亡了，该池中的线程会自动死亡。</li>
</ul>
</li>
</ul>
<h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><ul>
<li>用完一个线程池后，应该调用该线程池的shutdown()方法，调用该方法后，线程池不再接受新任务，但会将以前所有已提交的任务执行完成。当所有任务都执行完成，池中的所有线程都会死亡。</li>
<li>也可以调用shutdownNow()方法来关闭线程池，该方法试图停止所有正在执行的任务，暂停处理正在等待的任务，并返回等待执行的任务列表。</li>
</ul>
<h2 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h2><ul>
<li>背景：为了充分利用多CPU、多核CPU的优势，可以考虑把一个任务拆分成多个“小任务”，把多个“小任务”放到多个处理器核心上并行执行；当多个“小任务”执行完成后，再将这些执行结果合并起来即可。Java7提供了ForkJoinPool来支持将一个任务拆分成多个“小任务”并行执行，再把多个“小任务”的结果合并成总的结果。</li>
<li>简介：ForkJoinPool是ExecutorService的实现类，因此是一种特殊的线程池。</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>创建ForkJoinPool对象</li>
</ol>
<ul>
<li>使用Executors工具类<ul>
<li>ExecutorService newWorkStealingPool()</li>
<li>ExecutorService newWorkStealingPool(int parallelism)</li>
</ul>
</li>
<li>两个常用的构造器<ul>
<li>ForkJoinPool(int parallelism)：创建一个包含parallelism个并行线程的ForkJoinPool</li>
<li>ForkJoinPool()：相当于在上一个方法中传入参数Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors())，其中MAX_CAP = 0x7fff; </li>
</ul>
</li>
<li>Java8增加了通用池功能，提供了如下两个静态方法进行操作<ul>
<li>ForkJoinPool commonPool()：该方法返回一个通用池，其运行状态不会受shutdown()或shutdownNow()方法的影响。当然，如果程序直接执行System.exit(0);来终止虚拟机，通用池中正在执行的任务将自动终止。</li>
<li>int getCommonPoolParallelism()：返回通用池的并行级别。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>提交任务到ForkJoinPool</li>
</ol>
<ul>
<li>提交没有返回值的任务<ul>
<li>void execute(ForkJoinTask&lt;?&gt; task)</li>
<li>void execute(Runnable task)：Runnable最终包装成ForkJoinTask</li>
</ul>
</li>
<li>提交有返回值的任务<ul>
<li>public <t> ForkJoinTask<t> submit(ForkJoinTask<t> task)</t></t></t></li>
<li>public <t> ForkJoinTask<t> submit(Callable<t> task)</t></t></t></li>
<li>public <t> ForkJoinTask<t> submit(Runnable task, T result)</t></t></li>
<li>public ForkJoinTask&lt;?&gt; submit(Runnable task)</li>
</ul>
</li>
<li>同步提交，阻塞等结果返回<ul>
<li>public <t> T invoke(ForkJoinTask<t> task)</t></t></li>
</ul>
</li>
<li>总结：所有的任务最终都会以ForkJoinTask类型提交到线程池中</li>
</ul>
<h3 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h3><ul>
<li>ForkJoinTask是一个抽象类，其实现了Future接口。它还有两个抽象子类：RecursiveAction和RecursiveTask，RecursiveAction代表没有返回值的任务，而RecursiveTask代表有返回值的任务。<br><img src="https://img-blog.csdnimg.cn/2019032211104944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z6aGhzYQ==,size_16,color_FFFFFF,t_70" alt></li>
</ul>
<h4 id="RecursiveAction示例"><a href="#RecursiveAction示例" class="headerlink" title="RecursiveAction示例"></a>RecursiveAction示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印0~300</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveActionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        forkJoinPool.execute(<span class="keyword">new</span> PrintTask(<span class="number">0</span>, <span class="number">300</span>));    <span class="comment">//提交任务</span></span><br><span class="line">        forkJoinPool.awaitTermination(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//当等待超过设定时间时，会监测ExecutorService是否已经关闭，若关闭则返回true，否则返回false。</span></span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每个小任务最多打印个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PER_MAX = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写该方法，执行计算操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt; PER_MAX) &#123;    <span class="comment">//此时开始打印</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"：i = "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//要打印的数超过了最大值时，将大任务分解成两个“小任务”</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            PrintTask left = <span class="keyword">new</span> PrintTask(start, middle);</span><br><span class="line">            PrintTask right = <span class="keyword">new</span> PrintTask(middle, end);</span><br><span class="line">            <span class="comment">//并行执行两个“小任务”</span></span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RecursiveTask示例"><a href="#RecursiveTask示例" class="headerlink" title="RecursiveTask示例"></a>RecursiveTask示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用RecursiveTask对一个长度为100的数字的元素值进行累加</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveTaskTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建及初始化数组arr，元素值为1，2，...，100</span></span><br><span class="line">        <span class="keyword">int</span> [] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            arr[i] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建一个通用池</span></span><br><span class="line">        ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();</span><br><span class="line">        <span class="comment">//提交有返回值的任务</span></span><br><span class="line">        Future&lt;Integer&gt; future = forkJoinPool.submit(<span class="keyword">new</span> CalTask(arr, <span class="number">0</span>, arr.length));</span><br><span class="line">        <span class="comment">//获取结果</span></span><br><span class="line">        System.out.println(<span class="string">"结果为："</span> + future.get());</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        forkJoinPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//每个小任务最多累加数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PER_MAX = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> [] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CalTask</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt; PER_MAX) &#123;    <span class="comment">//开始进行累加</span></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//超过最大累加数是，将大任务分成两个“小任务”</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CalTask left = <span class="keyword">new</span> CalTask(arr, start, middle);</span><br><span class="line">            CalTask right = <span class="keyword">new</span> CalTask(arr, middle, end);</span><br><span class="line">            <span class="comment">//并行执行两个“小任务”</span></span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line">            <span class="comment">//把两个“小任务”累加的结果合并起来</span></span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://blog.csdn.net/caihaijiang/article/details/30812293" target="_blank" rel="noopener">Executors提供的四种线程池</a></li>
<li><a href="https://blog.csdn.net/Holmofy/article/details/82714665" target="_blank" rel="noopener">ForkJoinPool入门篇</a></li>
<li><a href="https://blog.csdn.net/wo541075754/article/details/51564359" target="_blank" rel="noopener">ExecutorService——shutdown方法和awaitTermination方法</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    
	
	<div>
	  
	</div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/23/线程笔记（3）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FengZH">
      <meta itemprop="description" content="阳光总在风雨后！坚持就是胜利！">
      <meta itemprop="image" content="http://baocangwh.cn/t6/702/1556201512x2728278694.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FengZH的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/23/线程笔记（3）/" class="post-title-link" itemprop="url">线程笔记（3）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-23 22:17:06 / 修改时间：22:18:06" itemprop="dateCreated datePublished" datetime="2019-04-23T22:17:06+08:00">2019-04-23</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java笔记/" itemprop="url" rel="index"><span itemprop="name">java笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h1><h2 id="传统的线程通信（wait、notify、notifyAll）"><a href="#传统的线程通信（wait、notify、notifyAll）" class="headerlink" title="传统的线程通信（wait、notify、notifyAll）"></a>传统的线程通信（wait、notify、notifyAll）</h2><ul>
<li>wait()、notify/notifyAll() 方法是Object的本地final方法，无法被重写。</li>
<li>这三个方法必须有同步监视器对象来调用，这可分为两种情况：  <ul>
<li>对于使用synchronized修饰的同步方法，因为该类的实例this就是同步监视器，所以可以在同步方法中直接使用这三个方法。</li>
<li>对于使用synchronized修饰的同步代码块，同步监视器就是synchronized后括号的对象，所以必须使用该对象调用这三个方法。</li>
</ul>
</li>
<li>wait():导致当前线程等待，直到其他线程调用该同步监视器的notify()方法或notifyAll()方法来唤醒该线程。调用wait方法的当前线程会释放对该同步监视器的锁定。</li>
<li>notify():唤醒在此同步监视器上等待的<strong>单个</strong>线程。如果有多个线程在此同步监视器上等待，则选择唤醒其中一个线程，这种选择是任意性的。</li>
<li>notifyAll():唤醒在此同步监视器上等待的<strong>所有</strong>线程。</li>
<li>注意：notify/notifyAll方法的执行只是唤醒沉睡的线程，而不会立即释放锁。直到执行完synchronized代码块的代码或者是调用wait方法，才会释放锁。所以在编程中，应尽量在使用了notify/notifyAll方法后立即退出临界区，以唤醒其他线程。</li>
</ul>
<h2 id="使用Condition控制线程通信"><a href="#使用Condition控制线程通信" class="headerlink" title="使用Condition控制线程通信"></a>使用Condition控制线程通信</h2><ul>
<li>如果程序不使用synchronized关键字来保证同步，而是直接使用Lock对象来保证同步，则系统中不存在同步监视器，也就不能使用wait、notify，notifyAll方法来进行线程通信了。这时候就要使用Condition了。</li>
<li>Condition实例被绑定在一个Lock对象上，其提供了如下三个方法：<ul>
<li>await()：类似于wait方法，导致当前线程等待，直到其他线程调用该Condition的signal或signalAll方法来唤醒该线程。</li>
<li>signal()：唤醒在此Lock对象上等待的单个线程。如果多个线程在等待，则会唤醒任意一个线程。</li>
<li>signalAll()：唤醒在此Lock对象上等待的所有线程。</li>
</ul>
</li>
<li>注意：signal或signalAll方法也是只有当前线程放弃对该Lock对象的锁定后，才可以执行被唤醒的线程。</li>
</ul>
<h2 id="使用阻塞队列（BlockingQueue）控制线程通信"><a href="#使用阻塞队列（BlockingQueue）控制线程通信" class="headerlink" title="使用阻塞队列（BlockingQueue）控制线程通信"></a>使用阻塞队列（BlockingQueue）控制线程通信</h2><ul>
<li>BlockingQueue接口是Queue的子接口，但它的主要作用并不是作为容器，而是作为线程同步的工具。</li>
<li>BlockingQueue接口的一个特征：当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则该线程被阻塞；当消费者线程试图从BlockingQueue中取出元素时，如果该队列已空，则该线程被阻塞。</li>
<li>BlockingQueue提供以下两个方法支持阻塞：<ul>
<li>put(E e)：尝试把E元素放入BlockingQueue中，如果该队列元素已满，则阻塞该线程。</li>
<li>take()：尝试从BlockingQueue中取出元素时，如果该队列的元素已空，则阻塞该线程。</li>
</ul>
</li>
</ul>
<h1 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h1><ul>
<li>java使用ThreadGroup来表示线程组，它可以对一批线程进行管理。</li>
<li>用户创建的<strong>所有</strong>线程都属于指定线程组，如果程序没有显示指定线程属于哪个线程组，则该线程默认和创建它的父线程处于同一线程组。</li>
<li>一旦某个线程指定了线程组之后，那么该线程将一直属于该线程组，直到该线程死亡，线程运行过程中<strong>不能改变</strong>它所属的线程组。</li>
</ul>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroupTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"主线程组的名字："</span> + Thread.currentThread().getThreadGroup().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"主线程组是否是后台线程组："</span> + Thread.currentThread().getThreadGroup().isDaemon());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个没有显示指定线程组的线程</span></span><br><span class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread(<span class="string">"线程1"</span>);</span><br><span class="line">        System.out.println(thread1.getName() + <span class="string">"所属的线程组："</span> + thread1.getThreadGroup().getName());</span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个新的线程组</span></span><br><span class="line">        ThreadGroup tg1 = <span class="keyword">new</span> ThreadGroup(<span class="string">"线程组1"</span>);</span><br><span class="line">        <span class="comment">//将该线程组设置为后台线程组</span></span><br><span class="line">        tg1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        System.out.println(tg1.getName() + <span class="string">"是否是后台线程组："</span> + tg1.isDaemon());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个指定了线程组的线程</span></span><br><span class="line">        MyThread thread2 = <span class="keyword">new</span> MyThread(tg1, <span class="string">"线程2"</span>);</span><br><span class="line">        System.out.println(thread2.getName() + <span class="string">"所属的线程组："</span> + thread2.getThreadGroup().getName());</span><br><span class="line">        System.out.println(thread2.getName() + <span class="string">"是否是后台线程："</span> + thread2.isDaemon());</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">主线程组的名字：main</span><br><span class="line">主线程组是否是后台线程组：false</span><br><span class="line">线程1所属的线程组：main</span><br><span class="line">线程组1是否是后台线程组：true</span><br><span class="line">线程2所属的线程组：线程组1</span><br><span class="line">线程2是否是后台线程：false</span><br><span class="line">执行线程：线程1</span><br><span class="line">执行线程：线程2</span><br></pre></td></tr></table></figure>
<h2 id="未处理异常"><a href="#未处理异常" class="headerlink" title="未处理异常"></a>未处理异常</h2><ul>
<li>ThreadGroup实现了Thread.UncaughtExceptionHandler接口，这是Thread类的一个内部接口，该接口内只有一个方法：void uncaughtException(Thread t, Throwable e);ThreadGroup通过该方法可以处理该线程组内的任意线程所抛出的未处理异常。</li>
<li>从java5开始，java加强了线程的异常处理，如果线程执行过程中抛出了一个未处理异常，JVM在结束该线程之前会自动查找该线程是否有对应的Thread.UncaughtExceptionHandler对象，如果找到该对象，那么将调用该对象的uncaughtException方法来处理该异常。</li>
<li>由于ThreadGroup实现了Thread.UncaughtExceptionHandler接口，所以每个线程所属的线程组将会作为该线程的默认异常处理器。</li>
<li>ThreadGroup中的uncaughtException方法实现如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parent.uncaughtException(t, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.UncaughtExceptionHandler ueh =</span><br><span class="line">            Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        <span class="keyword">if</span> (ueh != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ueh.uncaughtException(t, e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(e <span class="keyword">instanceof</span> ThreadDeath)) &#123;</span><br><span class="line">            System.err.print(<span class="string">"Exception in thread \""</span></span><br><span class="line">                             + t.getName() + <span class="string">"\" "</span>);</span><br><span class="line">            e.printStackTrace(System.err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看出，线程组处理异常的默认流程如下：</p>
<ol>
<li>如果该线程组有父线程组，则调用父线程组的uncaughtException方法</li>
<li>如果该线程类有默认的异常处理器（由DefaultUncaughtExceptionHandler方法设置），那么就调用该异常处理器来处理异常</li>
<li>如果该异常对象是ThreadDeath对象，则不做任何处理；否则，将异常跟踪栈的信息打印到System.err错误输出流，并结束该线程。</li>
</ol>
<h3 id="简单示例-1"><a href="#简单示例-1" class="headerlink" title="简单示例"></a>简单示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置主线程的异常处理器</span></span><br><span class="line">        Thread.currentThread().setUncaughtExceptionHandler(<span class="keyword">new</span> MyExHandler());</span><br><span class="line">        <span class="comment">//异常语句</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span> / <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"程序正常结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义自己的异常处理器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyExHandler</span> <span class="keyword">implements</span> <span class="title">Thread</span>.<span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(t.getName() + <span class="string">"线程出现了异常："</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main线程出现了异常：java.lang.ArithmeticException: / by zero</span><br></pre></td></tr></table></figure></p>
<p>可以看出，虽然异常处理器对未捕获的异常进行了处理，但程序<strong>依然不会正常结束</strong>。这说明异常处理器与通过catch捕获异常是不一样的————当使用catch捕获异常时，异常不会向上传播给上一级调用者；但使用异常处理器对异常进行处理之后，异常依然会传播给上一级调用者。  </p>
<p>如果加上try…catch块会怎样呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置主线程的异常处理器</span></span><br><span class="line">        Thread.currentThread().setUncaughtExceptionHandler(<span class="keyword">new</span> MyExHandler());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//异常语句</span></span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">5</span> / <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"catch处理，异常是："</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"程序正常结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">catch处理，异常是：java.lang.ArithmeticException: / by zero</span><br><span class="line">程序正常结束</span><br></pre></td></tr></table></figure></p>
<p>可以看出，异常是由catch块处理的，不会由异常处理器处理；而且异常不会向上传播给上一级调用者，程序可以正常结束。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.cnblogs.com/moongeek/p/7631447.html" target="_blank" rel="noopener">Java多线程学习之wait、notify/notifyAll详解</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    
	
	<div>
	  
	</div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/23/线程笔记（2）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FengZH">
      <meta itemprop="description" content="阳光总在风雨后！坚持就是胜利！">
      <meta itemprop="image" content="http://baocangwh.cn/t6/702/1556201512x2728278694.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FengZH的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/23/线程笔记（2）/" class="post-title-link" itemprop="url">线程笔记（2）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-23 22:14:26 / 修改时间：22:15:38" itemprop="dateCreated datePublished" datetime="2019-04-23T22:14:26+08:00">2019-04-23</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java笔记/" itemprop="url" rel="index"><span itemprop="name">java笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><h2 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h2><ul>
<li>当程序new了一个线程后，该线程就处于新建状态。</li>
<li>此时该线程仅仅由java虚拟机为其分配内存，并初始化其成员变量，并未表现出线程的动态特征，程序也不会执行其线程体。</li>
</ul>
<h2 id="就绪"><a href="#就绪" class="headerlink" title="就绪"></a>就绪</h2><ul>
<li>当线程对象调用其start方法后，该线程就处于就绪状态。</li>
<li>此时只是表示该线程可以运行了，并未真正开始运行，至于该线程何时开始运行则取决于JVM里线程调度器的调度。</li>
</ul>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ul>
<li>如果处于就绪状态的线程获得了CPU，开始执行线程体，则该线程处于运行状态。</li>
</ul>
<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>当发生如下情况时，线程将进入阻塞状态。</p>
<ul>
<li>线程调用sleep方法</li>
<li>线程调用了一个阻塞式的IO方法，在该方法返回之前，该线程被阻塞</li>
<li>线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有（与线程锁有关）</li>
<li>线程在等待某个通知（notify）</li>
<li>调用了suspend方法将线程挂起（该方法容易造成死锁，应该尽量避免使用该方法）</li>
</ul>
<h3 id="重新进入就绪状态"><a href="#重新进入就绪状态" class="headerlink" title="重新进入就绪状态"></a>重新进入就绪状态</h3><p>被阻塞的线程在合适的时候会重新进入就绪状态（注意是就绪状态而不是运行状态），针对上面的几种状况，线程重新进入就绪状态的条件分别为</p>
<ul>
<li>调用sleep方法的线程经过了指定时间</li>
<li>线程调用的阻塞式IO方法已经返回</li>
<li>线程成功获得了试图取得的同步监视器</li>
<li>线程正在等待某个通知时，其他线程发出了一个通知</li>
<li>调用了resume方法恢复被挂起的线程</li>
</ul>
<h2 id="死亡"><a href="#死亡" class="headerlink" title="死亡"></a>死亡</h2><p>线程会以如下三种方式结束，结束后线程就处于死亡状态。</p>
<ul>
<li>线程体执行完毕，线程正常结束</li>
<li>线程抛出一个未捕获的Exception或Error</li>
<li>直接调用该线程的stop方法结束该线程（该方法容易造成死锁，通常不推荐使用）</li>
</ul>
<h3 id="如何判断线程是否死亡"><a href="#如何判断线程是否死亡" class="headerlink" title="如何判断线程是否死亡"></a>如何判断线程是否死亡</h3><p>可以通过线程的isAlive方法判断，当线程处于就绪、运行、阻塞状态时，返回true；当线程处于新建、死亡状态时，返回false。</p>
<h2 id="线程状态转换图"><a href="#线程状态转换图" class="headerlink" title="线程状态转换图"></a>线程状态转换图</h2><p><img src="https://img-blog.csdnimg.cn/20181106200534194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z6aGhzYQ==,size_16,color_FFFFFF,t_70" alt></p>
<h1 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h1><h2 id="join线程"><a href="#join线程" class="headerlink" title="join线程"></a>join线程</h2><ul>
<li>当在某个程序执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到被join方法加入的线程执行完为止。</li>
</ul>
<h2 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h2><ul>
<li>后台线程是在后台运行的，为其他的线程提供服务。</li>
<li>后台线程有个特征：如果所有的前台线程都死亡，后台线程会自动死亡。</li>
<li>如何创建：通过调用Thread的setDaemon(true)方法可以将指定线程设置为后台线程，注意该方法要在start方法前调用。</li>
<li>主线程默认是前台线程，如果没有使用setDaemon(true)方法显示设置，那么前台线程创建的子线程默认是前台线程，后台线程创建的子线程默认是后台线程。</li>
</ul>
<h2 id="线程睡眠：sleep"><a href="#线程睡眠：sleep" class="headerlink" title="线程睡眠：sleep"></a>线程睡眠：sleep</h2><ul>
<li>Thread.sleep()方法：让当前正在执行的线程暂停一段时间，并进入阻塞状态。</li>
</ul>
<h2 id="线程让步：yield"><a href="#线程让步：yield" class="headerlink" title="线程让步：yield"></a>线程让步：yield</h2><ul>
<li>Thread.yield()方法：与sleep方法不同，该方法只是将该线程转入就绪状态。完全可能出现的情况是：当某个线程调用了yield方法暂停之后，线程调度器又将其调度出来重新执行。</li>
<li>当某个线程调用了yield方法暂停之后，只有优先级与当前线程相同，或者优先级高于当前线程的处于就绪状态的线程才会获得执行的机会。</li>
</ul>
<h3 id="关于sleep方法和yield方法的区别"><a href="#关于sleep方法和yield方法的区别" class="headerlink" title="关于sleep方法和yield方法的区别"></a>关于sleep方法和yield方法的区别</h3><ul>
<li>sleep方法暂停当前线程后，会给其他线程执行机会，不会理会其他线程的优先级；但yield方法只会给优先级相同，或优先级更高的线程执行机会</li>
<li>sleep方法会将线程转入阻塞状态，直到经过阻塞时间才会转入就绪状态；而yield方法不会将线程转入阻塞状态，它只是强制当前线程转入就绪状态，因此完全有可能某个线程调用了yield方法暂停之后，立即再次获得处理器资源而被执行。</li>
<li>sleep方法声明抛出了InterruptedException异常，而yield方法没有抛出异常。</li>
<li>sleep方法比yield方法有更好的可移植性，通常不建议使用yield方法来控制并发线程的执行。</li>
</ul>
<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>例如银行取钱问题，在某种情况下，可能出现两个取钱线程同时操作同一个账户的情况（虽然出现的可能性很小，但还是有可能会发生），这时假如两个线程都是取钱800，而账户余额只剩下1000，那么就可能出现取了两次800的情况而出现余额-600的情况，显然现实中是不允许这种事情发生的。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    <span class="comment">//同步代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的obj就是<strong>同步监视器</strong>，线程开始执行同步代码块之前，必须先获得对同步监视器的锁定，而任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成时，该线程才会释放对该同步监视器的锁定。</li>
<li>虽然java程序允许使用任何对象作为同步监视器，但同步监视器的目的就是阻止两个线程对同一个共享资源进行并发访问，因此通常推荐使用可能被并发访问的共享资源作为同步监视器。</li>
<li>在银行取钱问题中，可以把账户作为同步监视器，取钱过程作为同步代码块，这样就保证只有一个线程能够进行取钱操作，当一个线程的取钱操作结束后另一个线程才能取得同步监视器进行另外的取钱操作。</li>
</ul>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//取钱操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面的方法用synchronized修饰，是一个同步方法。对于同步方法，无需显示指定同步监视器，同步方法的同步监视器是this，也就是调用该方法的对象。</li>
<li>因为draw方法是一个同步方法，而该方法是账户类的一个方法，所以对于同一个账户变量来说，如果有多个线程操作该变量，那么同一时刻只能有一个线程能执行draw方法，其他线程执行draw方法时会阻塞，这样就保证了取钱操作的安全性。</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>可变类的线程安全是以降低程序的运行效率为代价的，为了减少线程安全带来的负面影响，程序可采取如下策略：  </li>
</ol>
<ul>
<li>不要对线程安全类的所有方法都进行同步，只对那些会改变共享资源的方法进行同步。</li>
<li>如果可变类有两种运行环境：单线程环境和多线程环境，则应该为可变类提供两种版本，即线程不安全版本和线程安全版本。在单线程环境中使用线程不安全版本来保证性能，在多线程环境中使用线程安全版本。例如JDK提供的StringBuilder和StringBuffer，在单线程环境下使用StringBuilder来保证较好的性能，在多线程环境中使用StringBuffer来保证安全。</li>
</ul>
<h2 id="释放同步监视器的锁定"><a href="#释放同步监视器的锁定" class="headerlink" title="释放同步监视器的锁定"></a>释放同步监视器的锁定</h2><h3 id="何时释放"><a href="#何时释放" class="headerlink" title="何时释放"></a>何时释放</h3><ul>
<li>当前线程的同步方法、同步代码块执行完毕</li>
<li>当前线程在执行同步方法、同步代码块时出现了未处理的Error或Exception而异常结束</li>
<li>当前线程执行同步方法或同步代码块时，程序执行了同步监视器对象的wait方法，则当前线程暂停，并释放同步监视器  </li>
</ul>
<h3 id="以下情况不会释放"><a href="#以下情况不会释放" class="headerlink" title="以下情况不会释放"></a>以下情况不会释放</h3><ul>
<li>当前线程执行同步方法或同步代码块时，程序调用了sleep、yield方法来暂停当前线程，当前线程不会释放同步监视器</li>
<li>当前线程执行同步代码块时，其他线程调用了当前线程的suspend方法将当前线程挂起，当前线程不会释放同步监视器。当然，程序应该尽量避免使用suspend和resume方法来控制线程。 </li>
</ul>
<h2 id="关于synchronized关键字"><a href="#关于synchronized关键字" class="headerlink" title="关于synchronized关键字"></a>关于synchronized关键字</h2><ul>
<li><a href="https://www.jianshu.com/p/d53bf830fa09" target="_blank" rel="noopener">https://www.jianshu.com/p/d53bf830fa09</a></li>
</ul>
<h2 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h2><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><ul>
<li>Lock提供了比synchronized方法和synchronized代码块更广泛的锁定操作，Lock允许实现更灵活的结构，可以具有差别很大的属性，并且支持多个相关的condition对象。</li>
</ul>
<h3 id="ReentrantLock（可重入锁）"><a href="#ReentrantLock（可重入锁）" class="headerlink" title="ReentrantLock（可重入锁）"></a>ReentrantLock（可重入锁）</h3><ul>
<li>Lock接口的实现类</li>
<li><p>基本使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        reentrantLock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//需要保证线程安全的代码</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//使用finally块来保证释放锁</span></span><br><span class="line">            reentrantLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>何时使用：需要实现ReentrantLock的独有功能时</p>
</li>
</ul>
<h4 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h4><ul>
<li><p>公平锁的创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock fairLock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>非公平锁的创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ReentrantLock unFairLock = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure>
</li>
<li><p>区别：公平锁指的是线程获取锁的顺序是按照加锁顺序来的，即先加锁的线程（执行lock方法）会优先获得锁，非公平锁指的是抢锁机制，先lock的线程不一定先获得锁。</p>
</li>
<li>非公平锁可能会产生饥饿现象，公平锁虽然不会产生饥饿现象，但是性能会比非公平锁差很多。</li>
</ul>
<h3 id="Lock与synchronized对比"><a href="#Lock与synchronized对比" class="headerlink" title="Lock与synchronized对比"></a>Lock与synchronized对比</h3><ul>
<li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现</li>
<li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li>
<li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li>
<li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li>
</ul>
<h3 id="ReentrantLock和synchronized对比"><a href="#ReentrantLock和synchronized对比" class="headerlink" title="ReentrantLock和synchronized对比"></a>ReentrantLock和synchronized对比</h3><ul>
<li>可重入性：从名字上理解，ReenTrantLock的字面意思就是可重入锁，其实synchronized关键字所使用的锁也是可重入的，两者关于这个的区别不大。两者都是同一个线程每进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。（lock了几次相对应就要unLock几次）</li>
<li>锁的实现：Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，两者的区别就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。</li>
<li>性能上：在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized。</li>
<li>便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</li>
</ul>
<h3 id="可重入锁和不可重入锁的区别"><a href="#可重入锁和不可重入锁的区别" class="headerlink" title="可重入锁和不可重入锁的区别"></a>可重入锁和不可重入锁的区别</h3><ul>
<li><a href="https://blog.csdn.net/u012545728/article/details/80843595" target="_blank" rel="noopener">https://blog.csdn.net/u012545728/article/details/80843595</a></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://baijiahao.baidu.com/s?id=1580877892723254760&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">Java：重入锁ReentrantLock详解、代码实战、与Synchronized对比</a></li>
<li><a href="https://www.cnblogs.com/-new/p/7256297.html" target="_blank" rel="noopener">java多线程系列(四)—ReentrantLock的使用</a></li>
<li><a href="https://www.cnblogs.com/baizhanshi/p/7211802.html" target="_blank" rel="noopener">ReenTrantLock可重入锁（和synchronized的区别）总结</a></li>
<li><a href="https://blog.csdn.net/u010325193/article/details/80497364" target="_blank" rel="noopener">ReentrantLock 的使用</a></li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>当两个线程互相等待对方释放同步监视器时就会发生死锁，Java虚拟机没有检测，也没有采取措施来处理死锁情况，所以多线程编程时应采取措施避免死锁发生。</li>
<li>一旦出现死锁，整个程序既不会发生任何异常，也不会给任何提示，只是所以线程处于阻塞状态，无法继续。</li>
</ul>
<h3 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h3><p>思路是创建两个字符串a和b，再创建两个线程A和B，让每个线程都用synchronized锁住字符串（A先锁a，再去锁b；B先锁b，再锁a），如果A锁住a，B锁住b，A就没办法锁住b，B也没办法锁住a，这时就陷入了死锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String obj1 = <span class="string">"obj1"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String obj2 = <span class="string">"obj2"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Lock1()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Lock2()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Lock1 running"</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(DeadLock.obj1)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Lock1 lock obj1"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);<span class="comment">//获取obj1后先等一会儿，让Lock2有足够的时间锁住obj2</span></span><br><span class="line">                    <span class="keyword">synchronized</span>(DeadLock.obj2)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Lock1 lock obj2"</span>);  </span><br><span class="line">                        <span class="comment">//不会执行到这句，因为obj2锁已经被Lock2持有，而Lock2需要获取obj1锁，</span></span><br><span class="line">                        <span class="comment">//但obj1锁已经被Lock1持有，所以Lock2也不能获取到obj1锁</span></span><br><span class="line">                        <span class="comment">//造成的后果是：Lock1和Lock2都在等待对方执行完代码后释放自己所需的锁，</span></span><br><span class="line">                        <span class="comment">//但双方的代码都需要持有已经被对方持有的锁，所以就形成一个死循环。</span></span><br><span class="line">                        <span class="comment">//双方都在等待对方释放锁，程序也就变成了虽然没有报错，但运行不下去的情况。</span></span><br><span class="line">                        <span class="comment">//这就是死锁</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Lock2 running"</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(DeadLock.obj2)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Lock2 lock obj2"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span>(DeadLock.obj1)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Lock2 lock obj1"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lock1 running</span><br><span class="line">Lock1 lock obj1</span><br><span class="line">Lock2 running</span><br><span class="line">Lock2 lock obj2</span><br></pre></td></tr></table></figure></p>
<p>可以看出，最终程序没有报错，但却停在了这里运行不下去，两个线程都变成了阻塞状态，形成了是死锁。</p>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.cnblogs.com/mudao/p/5867107.html" target="_blank" rel="noopener">Java产生死锁的一个简单例子</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    
	
	<div>
	  
	</div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/22/线程笔记（1）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FengZH">
      <meta itemprop="description" content="阳光总在风雨后！坚持就是胜利！">
      <meta itemprop="image" content="http://baocangwh.cn/t6/702/1556201512x2728278694.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FengZH的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/22/线程笔记（1）/" class="post-title-link" itemprop="url">线程笔记（1）</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-22 22:10:26" itemprop="dateCreated datePublished" datetime="2019-04-22T22:10:26+08:00">2019-04-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-23 09:09:15" itemprop="dateModified" datetime="2019-04-23T09:09:15+08:00">2019-04-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java笔记/" itemprop="url" rel="index"><span itemprop="name">java笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h1><h2 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h2><p>根本区别：</p>
<ul>
<li>进程是是系统进行资源分配和调度的基本单位</li>
<li>线程是进程中的一个实体，是被系统独立调度和分派的基本单位</li>
</ul>
<p>在开销方面：</p>
<ul>
<li>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销</li>
<li>线程可以看做<strong>轻量级的进程</strong>，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li>
</ul>
<p>资源和内存方面：</p>
<ul>
<li>进程是系统中一个活动的实体，它可以拥有自己独立的资源。每个进程都拥有自己独立的内存空间。</li>
<li>除了CPU外，系统不会为线程分配内存。线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它<strong>可与同属一个进程的其它线程共享进程所拥有的全部资源</strong></li>
</ul>
<h2 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h2><p>多个进程在单个处理器上并发执行，同一进程中的多个线程之间可以并发执行。<br>说到并发，还有一个与之相关的并行。并发与并行是两个既相似而又不相同的概念：</p>
<ul>
<li>并发性，又称共行性，是指能处理多个同时性活动的能力。是在同一个cpu上同时（不是真正的同时，而是看来是同时，因为cpu要在多个程序间切换）运行多个程序。；</li>
<li>并行是指同时发生的两个并发事件，即每个cpu运行一个程序。并行具有并发的含义，而并发则不一定并行，也亦是说并发事件之间不一定要同一时刻发生。<blockquote>
<p>总的来说，并发指在同一时刻只能有一条指令执行，但多个指令被快速轮换执行，使得在宏观上具有多个活动同时进行的效果。而并行指在同一时刻，有多条指令在多个处理器上同时执行。</p>
</blockquote>
</li>
</ul>
<h2 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h2><ul>
<li>线程是进程的组成部分，一个进程可以拥有多个线程，一个进程必须有一个父进程。</li>
<li>如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的。</li>
<li>一个程序运行后至少包含一个进程，一个进程里可以包含多个线程，但至少要包含一个线程。</li>
</ul>
<h1 id="多线程的优势"><a href="#多线程的优势" class="headerlink" title="多线程的优势"></a>多线程的优势</h1><ul>
<li>进程之间不能共享内存，但线程之间共享内存非常容易。（因为多个进程共享父进程的内存空间）</li>
<li>系统创建进程时需要为该进程重新分配系统资源，但创建线程则代价小得多（同样是因为同一个进程下的线程共享进程的资源），因此使用多线程来实现多任务并发比多进程效率高。</li>
<li>Java内置了多线程功能支持，从而简化了Java的多线程编程。</li>
</ul>
<h1 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h1><h2 id="继承Thread类创建线程类"><a href="#继承Thread类创建线程类" class="headerlink" title="继承Thread类创建线程类"></a>继承Thread类创建线程类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;	<span class="comment">//不同线程对象不能共享该成员变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 重写run方法，该方法为线程的执行体</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(getName() + <span class="string">": i = "</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFirstThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> FirstThread().start();</span><br><span class="line">		<span class="keyword">new</span> FirstThread().start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main方法中创建了两次该线程类，并调用start方法开启线程，然后执行线程中的run方法。</p>
<blockquote>
<p>注意：使用继承Thread类创建线程类时，不同线程对象不能共享该线程类的成员变量</p>
</blockquote>
<p>上述代码输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread-0: i = 0</span><br><span class="line">Thread-1: i = 0</span><br><span class="line">Thread-1: i = 1</span><br><span class="line">Thread-0: i = 1</span><br><span class="line">Thread-1: i = 2</span><br><span class="line">Thread-1: i = 3</span><br><span class="line">Thread-1: i = 4</span><br><span class="line">Thread-1: i = 5</span><br><span class="line">Thread-1: i = 6</span><br><span class="line">Thread-1: i = 7</span><br><span class="line">Thread-1: i = 8</span><br><span class="line">Thread-1: i = 9</span><br><span class="line">Thread-0: i = 2</span><br><span class="line">Thread-0: i = 3</span><br><span class="line">Thread-0: i = 4</span><br><span class="line">Thread-0: i = 5</span><br><span class="line">Thread-0: i = 6</span><br><span class="line">Thread-0: i = 7</span><br><span class="line">Thread-0: i = 8</span><br><span class="line">Thread-0: i = 9</span><br></pre></td></tr></table></figure></p>
<h2 id="实现Runnable接口创建线程"><a href="#实现Runnable接口创建线程" class="headerlink" title="实现Runnable接口创建线程"></a>实现Runnable接口创建线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">": i = "</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSecondThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SecondThread st = <span class="keyword">new</span> SecondThread();	<span class="comment">//作为target传入Thread的构造方法</span></span><br><span class="line">		<span class="keyword">new</span> Thread(st).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(st).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread-0: i = 0</span><br><span class="line">Thread-0: i = 1</span><br><span class="line">Thread-1: i = 0</span><br><span class="line">Thread-0: i = 2</span><br><span class="line">Thread-0: i = 4</span><br><span class="line">Thread-0: i = 5</span><br><span class="line">Thread-0: i = 6</span><br><span class="line">Thread-1: i = 3</span><br><span class="line">Thread-1: i = 8</span><br><span class="line">Thread-1: i = 9</span><br><span class="line">Thread-0: i = 7</span><br></pre></td></tr></table></figure>
<p>从运行结果可以发现用这种方法创建的多个线程可以共享线程类（严格来说不是线程类，只是和线程类一样实现了Runnable接口，说它是线程类的target更合适）的成员变量。下面会分析为什么会这样。</p>
<h2 id="从源码角度分析以上两种方法"><a href="#从源码角度分析以上两种方法" class="headerlink" title="从源码角度分析以上两种方法"></a>从源码角度分析以上两种方法</h2><p>其实查看源码可以发现，以上这两种方法虽然实现不同，但内在的原理是一样的。</p>
<h3 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Thread implements Runnable &#123;</span><br><span class="line">    //........</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (target != null) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Thread实现了Runnable接口并重写了run方法。FirstThread方法继承了Thread，其实也就是实现了Runnable接口，然后重写了run方法。<br>第一种方法开启线程是这样的：<strong>new FirstThread().start();</strong> 它执行了Thread的无参构造方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Thread() &#123;</span><br><span class="line">    init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们重点看第二个参数Runnable target，这里的target为null，也就是说第一种方式实现不需要target，但第二种方式会不一样。</p>
<h3 id="实现Runnable"><a href="#实现Runnable" class="headerlink" title="实现Runnable"></a>实现Runnable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Runnable接口只有一个方法，而SecondThread实现了该接口并重写了这个方法。所以实际上SecondThread也是一个Runnable，也就是说SecondThread可以作为Thread类的一个target。   </p>
<p>第二种方法开启线程是这样的:<strong>new Thread(st).start();</strong> 它执行了Thread的含有一个Runnable参数的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的第二个参数不在是null，而是传来的参数target，然后在init方法执行过后，SecondThread对象被赋给了Thread的成员变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable target;</span><br></pre></td></tr></table></figure></p>
<p>所以现在虽然Thread的run方法没有被重写，但它实际上是调用了target的run方法，也就是SecondThread中重写的run方法。不妨再看一次Thread重写的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以说，这两种方法的实质都是重写了Thread中的run方法，只不过是<strong>直接重写该方法</strong>和调用<strong>target所重写的该方法</strong>的区别。</p>
<h3 id="两种方式所带来的不同"><a href="#两种方式所带来的不同" class="headerlink" title="两种方式所带来的不同"></a>两种方式所带来的不同</h3><p>分析过源码后，现在就更加清楚为什么不同的实现，会产生成员变量是否可以共享的问题。  </p>
<ul>
<li><p>首先是第一种方式，这里new了两个Thread的子类，也就是说有两个对象，等于实现了两个接口对象，那么接口中的run方法的变量自然不能共享了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> FirstThread().start();</span><br><span class="line"><span class="keyword">new</span> FirstThread().start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后是第二种，这里虽然也是new了两个Thread，但是只有一个接口对象，就是st,那么接口中的run方法的变量自然就可以共享了（因为就只有这一个接口对象，也就是说只有这个变量，当然只能共享了）。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SecondThread st = <span class="keyword">new</span> SecondThread();	<span class="comment">//作为target传入Thread的构造方法</span></span><br><span class="line"><span class="keyword">new</span> Thread(st).start();</span><br><span class="line"><span class="keyword">new</span> Thread(st).start();</span><br></pre></td></tr></table></figure>
<p>其实弄懂了这些后，我们也可以用第二种方式实现第一种的效果，只要多创建一个SecondThread（Runnable）对象就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SecondThread st = <span class="keyword">new</span> SecondThread();</span><br><span class="line">SecondThread st1 = <span class="keyword">new</span> SecondThread();</span><br><span class="line"><span class="keyword">new</span> Thread(st).start();</span><br><span class="line"><span class="keyword">new</span> Thread(st1).start();</span><br></pre></td></tr></table></figure>
<p>改为上述代码之后，再运行就会和第一种方式的效果一样。原因很简单，这里多了一个SecondThread对象，两者的变量当然是不能共享的，因为根本就不在同一块存储空间。</p>
<h2 id="使用Callable和Future创建线程"><a href="#使用Callable和Future创建线程" class="headerlink" title="使用Callable和Future创建线程"></a>使用Callable和Future创建线程</h2><h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><p>Callable接口提供了一个call方法作为线程执行体，call方法比run方法更加强大。</p>
<ul>
<li>call方法可以有返回值</li>
<li>call方法可以声明抛出异常  </li>
</ul>
<p>但是Callable接口不是Runnable接口的子接口，所以不能作为Thread的target。那么要怎么把Callable和Thread联系起来呢？</p>
<blockquote>
<p>Java5提供了Future接口来代表Callable接口里call方法的返回值，并提供了一个FutureTask实现类（该类既实现了Future接口，又实现了Runnable接口，所以可以作为Thread的target）</p>
</blockquote>
<h3 id="创建线程步骤"><a href="#创建线程步骤" class="headerlink" title="创建线程步骤"></a>创建线程步骤</h3><ul>
<li>创建一个Callable接口对象，重写call方法</li>
<li>FutureTask对象并使用FutureTask来包装Callable对象</li>
<li>将FutureTask对象作为target传入Thread的构造函数</li>
<li>最后可以通过FutureTask对象的get()方法获得Callable线程的返回值</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>FutureTask对象的泛型参数必须和Callable对象的泛型参数一致</li>
<li>call方法会导致主线程阻塞，直到call方法结束并返回为止</li>
</ul>
<h2 id="三种方式的对比"><a href="#三种方式的对比" class="headerlink" title="三种方式的对比"></a>三种方式的对比</h2><p>实现Runnable接口、Callable接口的方式基本相同，可以归为一类。它们和直接继承Thread类的优缺点如下。</p>
<h3 id="实现Runnable接口、Callable接口的优缺点"><a href="#实现Runnable接口、Callable接口的优缺点" class="headerlink" title="实现Runnable接口、Callable接口的优缺点"></a>实现Runnable接口、Callable接口的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>还可以继承其他类</li>
<li>多个线程可以共享一个target，非常适合多个相同的线程来处理同一资源。<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>编程稍微复杂（其实也不算复杂，所以这个缺点可以忽略不计）</li>
</ul>
<h3 id="直接继承Thread类的优缺点"><a href="#直接继承Thread类的优缺点" class="headerlink" title="直接继承Thread类的优缺点"></a>直接继承Thread类的优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>编写简单<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>不能继承其他父类</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般推荐采用实现Runnable接口、Callable接口的方法创建线程</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://blog.csdn.net/haiross/article/details/36895449" target="_blank" rel="noopener">https://blog.csdn.net/haiross/article/details/36895449</a></li>
<li><a href="https://blog.csdn.net/kuangsonghan/article/details/80674777" target="_blank" rel="noopener">https://blog.csdn.net/kuangsonghan/article/details/80674777</a></li>
<li>《疯狂Java讲义》第3版</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    
	
	<div>
	  
	</div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/20/EventBus的基本使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FengZH">
      <meta itemprop="description" content="阳光总在风雨后！坚持就是胜利！">
      <meta itemprop="image" content="http://baocangwh.cn/t6/702/1556201512x2728278694.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FengZH的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/20/EventBus的基本使用/" class="post-title-link" itemprop="url">EventBus的基本使用</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-20 19:39:13" itemprop="dateCreated datePublished" datetime="2019-04-20T19:39:13+08:00">2019-04-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-23 09:19:30" itemprop="dateModified" datetime="2019-04-23T09:19:30+08:00">2019-04-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>EventBus是一种用于Android的发布/订阅事件总线。它有很多优点：简化应用组件间的通信；解耦事件的发送者和接收者；避免复杂和容易出错的依赖和生命周期的问题；很快，专门为高性能优化过等等。</p>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li><p>创建一个工具类，里面封装了一些基本方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBusUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">        EventBus.getDefault().register(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">        EventBus.getDefault().unregister(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        EventBus.getDefault().post(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendStickyEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">        EventBus.getDefault().postSticky(event);    <span class="comment">//后续注册的订阅者依然可以从内存中得到这个已发送的sticky事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个基本事件类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;   <span class="comment">//该字段用于判断事件的发送源</span></span><br><span class="line">    <span class="keyword">private</span> T data;     <span class="comment">//事件类型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Event</span><span class="params">(<span class="keyword">int</span> code, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>封装到基类（BaseActivity、BaseFragment）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否注册EventBus，注册后才可以订阅事件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true表示绑定EventBus事件分发，默认不绑定，子类需要绑定的话复写此方法返回true.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isRegisterEventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在onCreated方法中加入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isRegisterEventBus()) &#123;</span><br><span class="line">    EventBusUtil.register(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在onDestroy方法中加入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isRegisterEventBus()) &#123;</span><br><span class="line">    EventBusUtil.unregister(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="在代码中使用"><a href="#在代码中使用" class="headerlink" title="在代码中使用"></a>在代码中使用</h2><ol>
<li>接收事件  </li>
</ol>
<p>例如某个Activity要接收事件，则其首先要注册Eventbus<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isRegisterEventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后写一个接收事件的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventCome</span><span class="params">(Event&lt;MainEvent&gt; event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.getCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> EventBusCode.Login2Main:</span><br><span class="line">        <span class="keyword">case</span> EventBusCode.Register2Main:</span><br><span class="line">            updateAfterLoginOrRegister(event.getData().getUserName());  <span class="comment">//更新用户信息</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>EventBusCode是用来区分不同活动发来的事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class EventBusCode &#123;</span><br><span class="line">    public static final int Register2Main = 0;</span><br><span class="line">    public static final int Login2Main = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>发送事件<br>例如在登录活动中发送一个事件给主活动<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新用户信息</span></span><br><span class="line">Event&lt;MainEvent&gt; mainEvent = <span class="keyword">new</span> Event&lt;&gt;(EventBusCode.Login2Main, <span class="keyword">new</span> MainEvent(userName));</span><br><span class="line">EventBusUtil.sendEvent(mainEvent);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="发送黏性事件"><a href="#发送黏性事件" class="headerlink" title="发送黏性事件"></a>发送黏性事件</h1><p>所谓的黏性事件，就是指发送了该事件之后再注册的订阅者依然能够接收到的事件。简单来说就是可以把事件发送到未启动的活动中。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li><p>在订阅事件处添加 sticky = true属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.MAIN, sticky = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStickyEventBusCome</span><span class="params">(Event&lt;ShowArticleEvent&gt; event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.getCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> EventBusCode.Home2ShowArticle:</span><br><span class="line">            mLink = event.getData().getLink();</span><br><span class="line">            mTitle = event.getData().getTitle();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布事件处发送黏性事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBusUtil.sendStickyEvent(event);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><ul>
<li><a href="https://www.jianshu.com/p/e00297348f17" target="_blank" rel="noopener">https://www.jianshu.com/p/e00297348f17</a></li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://www.jianshu.com/p/f9ae5691e1bb" target="_blank" rel="noopener">https://www.jianshu.com/p/f9ae5691e1bb</a></li>
<li><a href="https://blog.csdn.net/u012317510/article/details/78935720" target="_blank" rel="noopener">https://blog.csdn.net/u012317510/article/details/78935720</a></li>
<li><a href="https://www.jianshu.com/p/e7d5c7bda783" target="_blank" rel="noopener">https://www.jianshu.com/p/e7d5c7bda783</a></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    
	
	<div>
	  
	</div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/18/java集合之HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FengZH">
      <meta itemprop="description" content="阳光总在风雨后！坚持就是胜利！">
      <meta itemprop="image" content="http://baocangwh.cn/t6/702/1556201512x2728278694.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FengZH的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/18/java集合之HashMap/" class="post-title-link" itemprop="url">java集合之HashMap</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-02-18 17:59:33" itemprop="dateCreated datePublished" datetime="2019-02-18T17:59:33+08:00">2019-02-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-23 09:19:55" itemprop="dateModified" datetime="2019-04-23T09:19:55+08:00">2019-04-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java笔记/" itemprop="url" rel="index"><span itemprop="name">java笔记</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>用于存储键值对（key-value），其中key不可以重复，value可以重复。</li>
<li><p>基本用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化，第一个泛型是key的类型，第二个是values</span></span><br><span class="line">HashMap&lt;Integer, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">hashMap.put(<span class="number">1</span>, <span class="string">"first"</span>);</span><br><span class="line">hashMap.put(<span class="number">2</span>, <span class="string">"second"</span>);</span><br><span class="line">hashMap.put(<span class="number">3</span>, <span class="string">"third"</span>);</span><br><span class="line"><span class="comment">//hashMap.put(3, "doubleThird");    //会覆盖原先的&lt;3，third&gt;</span></span><br><span class="line">System.out.println(hashMap);    <span class="comment">//&#123;1=first, 2=second, 3=third&#125;</span></span><br><span class="line">System.out.println(hashMap.get(<span class="number">0</span>));     <span class="comment">//null</span></span><br><span class="line">System.out.println(hashMap.get(<span class="number">1</span>));     <span class="comment">//first</span></span><br><span class="line">System.out.println(hashMap.containsKey(<span class="number">1</span>)); <span class="comment">//true</span></span><br><span class="line">System.out.println(hashMap.containsValue(<span class="string">"third"</span>)); <span class="comment">//true</span></span><br><span class="line">System.out.println(hashMap.remove(<span class="number">10</span>)); <span class="comment">//null</span></span><br><span class="line">System.out.println(hashMap.remove(<span class="number">2</span>));  <span class="comment">//second</span></span><br><span class="line">System.out.println(hashMap);    <span class="comment">//&#123;1=first, 3=third&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span> (Object o : hashMap.keySet()) &#123;</span><br><span class="line">    <span class="keyword">int</span> key = (<span class="keyword">int</span>) o;</span><br><span class="line">    System.out.println(<span class="string">"key = "</span> + key + <span class="string">", values = "</span> + hashMap.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种遍历方法</span></span><br><span class="line">Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set = hashMap.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : set) &#123;</span><br><span class="line">    System.out.println(<span class="string">"key = "</span> + entry.getKey() + <span class="string">", values = "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HashMap和Hashtable的区别  </p>
</li>
</ul>
<ol>
<li>Hashtable是一个线程安全的Map实现，而HashMap是一个<strong>线程不安全</strong>的实现。所有HashMap的性能会高一点。</li>
<li>Hashtable不允许null作为key或value的元素，如果使用会抛出异常，但HashMap允许null作为key或value的元素。HashMap允许一个key为null，允许多个value为null。 </li>
</ol>
<ul>
<li><p>用作key的对象必须实现了equals()和hashCode()方法，因为判断两个key相等的条件是：通过equals()方法比较后返回true，并且两者的hashCode()方法返回的值相等。所以如果重写了对象的equals()方法，必须保证两个方法的判断标准一致，即equals()方法返回true时，返回的hashCode也要相等。当我们使用自定义对象作为key时，也要重写这两个方法并保持判断标准一致。  </p>
</li>
<li><p>HashMap和LinkedHashMap的区别</p>
</li>
</ul>
<ol>
<li>HashMap是无序的：其遍历的顺序与其插入的顺序不一样，而LinkedHashMap是有序的：其遍历的顺序和其插入的顺序一致</li>
<li>LinkedHashMap需要维护元素的顺序，所以性能略低于HashMap，但由于它是以链表维护元素的顺序，所以在迭代元素的时候性能会好一些。</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    
	
	<div>
	  
	</div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://baocangwh.cn/t6/702/1556201512x2728278694.jpg" alt="FengZH">
            
              <p class="site-author-name" itemprop="name">FengZH</p>
              <div class="site-description motion-element" itemprop="description">阳光总在风雨后！坚持就是胜利！</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Mrfzh" title="GitHub &rarr; https://github.com/Mrfzh" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:15521206029@163.com" title="E-Mail &rarr; mailto:15521206029@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FengZH</span>

  

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>



  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
